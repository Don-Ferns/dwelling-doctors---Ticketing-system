/** Office Script: Single table with strict matching, 2-decimals, per-category split,
 * and inline job ID lists (clip in-cell without shrinking)
 *
 * Source sheet columns:
 *   A = Date/Time | B = Scheduler | C = Job ID | D = Message
 * Output sheet: "Scheduler Summary"
 */
function main(workbook: ExcelScript.Workbook) {
  // ---- CONFIG ----
  const SOURCE_SHEET_NAME: string | null = null; // e.g., "Dump"; null = first sheet
  const OUTPUT_SHEET_NAME = "Scheduler Summary";
  const ID_SEPARATOR = " , "; // space, comma, space
  const ID_COLUMN_WIDTH = 18; // characters approx; tweak as you like

  // Exact substrings to match (quotes included), case-insensitive
  const SUB_SURVEY_TO = `to "Survey Booked"`.toLowerCase();
  const SUB_JOB_TO    = `to "Job : Scheduled"`.toLowerCase();

  // ---- Get source data ----
  const wsSrc = SOURCE_SHEET_NAME
    ? workbook.getWorksheet(SOURCE_SHEET_NAME)
    : workbook.getWorksheets()[0];
  if (!wsSrc) throw new Error("Source worksheet not found.");

  const used = wsSrc.getUsedRange();
  if (!used) throw new Error("No data found on source sheet.");

  const values = used.getValues() as (string | number | boolean | null)[][];
  if (values.length < 2) throw new Error("No data rows found (need headers + at least 1 row).");

  const COL_SCHED = 1, COL_JOB = 2, COL_MSG = 3;

  // ---- Build per-category: cleanedJobID -> Set(schedulers) ----
  const jobToSched_Survey = new Map<string, Set<string>>();
  const jobToSched_Job    = new Map<string, Set<string>>();

  for (let r = 1; r < values.length; r++) {
    const sched = safeStr(values[r][COL_SCHED]).trim();
    const jobRaw = safeStr(values[r][COL_JOB]).trim();
    const msg    = safeStr(values[r][COL_MSG]).trim();
    if (!sched || !jobRaw || !msg) continue;

    const msgLow = msg.toLowerCase();
    const jobID = cleanJobID(jobRaw);
    if (!jobID) continue;

    if (msgLow.includes(SUB_SURVEY_TO)) add(jobToSched_Survey, jobID, sched);
    if (msgLow.includes(SUB_JOB_TO))    add(jobToSched_Job, jobID, sched);
  }

  // ---- Totals: 1 point per job in category, split evenly among schedulers ----
  const totalsSurvey = calcTotals(jobToSched_Survey);
  const totalsJob    = calcTotals(jobToSched_Job);

  // ---- Per-scheduler job ID lists (cleaned & deduped) ----
  const schedToJobs_Survey = invertToSchedJobList(jobToSched_Survey);
  const schedToJobs_Job    = invertToSchedJobList(jobToSched_Job);

  // ---- Consolidated rows ----
  const allNames = new Set<string>([
    ...totalsSurvey.keys(),
    ...totalsJob.keys(),
    ...schedToJobs_Survey.keys(),
    ...schedToJobs_Job.keys()
  ]);

  type Row = {
    name: string; survey: number; job: number; total: number;
    surveyIDs: string; jobIDs: string;
  };

  const rows: Row[] = Array.from(allNames).map(name => {
    const surveyPts = totalsSurvey.get(name) ?? 0;
    const jobPts    = totalsJob.get(name) ?? 0;
    const surveyIDsArr = Array.from(schedToJobs_Survey.get(name) ?? []);
    const jobIDsArr    = Array.from(schedToJobs_Job.get(name) ?? []);
    surveyIDsArr.sort(); jobIDsArr.sort();
    return {
      name,
      survey: surveyPts,
      job: jobPts,
      total: surveyPts + jobPts,
      surveyIDs: surveyIDsArr.join(ID_SEPARATOR),
      jobIDs: jobIDsArr.join(ID_SEPARATOR)
    };
  }).sort((a, b) => (b.total - a.total) || a.name.localeCompare(b.name));

  const sums = rows.reduce((acc, r) => {
    acc.survey += r.survey; acc.job += r.job; acc.total += r.total; return acc;
  }, { survey: 0, job: 0, total: 0 });

  // ---- Write output ----
  let wsOut = workbook.getWorksheet(OUTPUT_SHEET_NAME);
  if (!wsOut) wsOut = workbook.addWorksheet(OUTPUT_SHEET_NAME);
  else wsOut.getUsedRange()?.clear(ExcelScript.ClearApplyTo.all);

  // Headers
  wsOut.getRange("A1:F1").setValues([[
    "Name", "Survey Booked", "Job : Scheduled", "Total",
    "Survey Job IDs", "Job : Scheduled Job IDs"
  ]]);
  wsOut.getRange("A1:F1").getFormat().getFont().setBold(true);

  // Body (points rounded to 2 decimals)
  if (rows.length > 0) {
    const body = rows.map(r => [
      r.name, round2(r.survey), round2(r.job), round2(r.total), r.surveyIDs, r.jobIDs
    ]);
    wsOut.getRangeByIndexes(1, 0, body.length, 6).setValues(body);
  }

  // Footer rows (leave job ID columns blank)
  const totalsRow = rows.length + 2;
  wsOut.getRangeByIndexes(totalsRow - 1, 0, 1, 6).setValues([
    ["Column totals", round2(sums.survey), round2(sums.job), round2(sums.total), "", ""]
  ]);
  wsOut.getRange(`A${totalsRow}:F${totalsRow}`).getFormat().getFont().setBold(true);

  const grandRow = totalsRow + 1;
  wsOut.getRangeByIndexes(grandRow - 1, 0, 1, 6).setValues([
    ["Grand total", "", "", round2(sums.total), "", ""]
  ]);
  wsOut.getRange(`A${grandRow}:F${grandRow}`).getFormat().getFont().setBold(true);

  // ---- Formatting: numbers + clip ID text (no wrap, no shrink, fixed width) ----
  wsOut.getRange(`B2:D${grandRow}`).setNumberFormatLocal("0.00");

  // Clip long ID lists: do NOT wrap, do NOT shrink; keep a stable column width
  const idRange = wsOut.getRange(`E1:F${grandRow}`);
  const idFmt = idRange.getFormat();
  idFmt.setWrapText(false);
  idFmt.setShrinkToFit(false);
  idFmt.setHorizontalAlignment(ExcelScript.HorizontalAlignment.left);
  idFmt.setVerticalAlignment(ExcelScript.VerticalAlignment.center);

  // Set a consistent width for ID columns; do NOT autofit them
  wsOut.getRange("E:E").getFormat().setColumnWidth(ID_COLUMN_WIDTH);
  wsOut.getRange("F:F").getFormat().setColumnWidth(ID_COLUMN_WIDTH);

  // Autofit only the first four columns
  wsOut.getRange("A:D").getFormat().autofitColumns();

  wsOut.activate();

  // ---- Helpers ----
  function safeStr(v: unknown): string {
    if (v === null || v === undefined) return "";
    if (typeof v === "string") return v;
    if (typeof v === "number" || typeof v === "boolean") return String(v);
    return "";
  }
  function add(map: Map<string, Set<string>>, job: string, name: string) {
    if (!map.has(job)) map.set(job, new Set<string>());
    map.get(job)!.add(name);
  }
  function calcTotals(jobToSched: Map<string, Set<string>>): Map<string, number> {
    const out = new Map<string, number>();
    for (const [, schedSet] of jobToSched.entries()) {
      const n = schedSet.size;
      if (n === 0) continue;
      const credit = 1 / n;
      for (const s of schedSet) out.set(s, (out.get(s) ?? 0) + credit);
    }
    return out;
  }
  function invertToSchedJobList(jobToSched: Map<string, Set<string>>): Map<string, Set<string>> {
    const out = new Map<string, Set<string>>();
    for (const [job, schedSet] of jobToSched.entries()) {
      for (const s of schedSet) {
        if (!out.has(s)) out.set(s, new Set<string>());
        out.get(s)!.add(job);
      }
    }
    return out;
  }
  function cleanJobID(raw: string): string {
    let s = raw.trim();
    s = s.replace(/^\s*job\s*(no\.?|number|#|id)?\s*[:\-]?\s*/i, "");
    return s.trim();
  }
  function round2(n: number): number {
    return Math.round(n * 100) / 100;
  }
}
